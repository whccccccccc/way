# 带着问题学习 慢慢积累


# 打印数组的方式
- Arrays.toString()
- Arrays.deepToString() 打印二维数组
- Pojo类都必须重写toString方法  如果引入了其他类 那么引入类也需要重写 并且调用.toString() 继承一个类 也要调用super.toString

# 什么是 POJO 呢?
>就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。
# 为什么String是不可变的?
- String 是final 意味着不可被继承
- String 实现了Serializable 接口说明可以序列化
- String 实现了Comparable,意味着可以进行两个字符串的比较
- StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，StringBuffer 和 StringBuilder，它俩是可变的
- Java9以前String使用char型数组实现的,之后改成了byte型数组实现,并增加了coder来表示编码在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销
- 每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值
# 为什么要这样设计呢?
- 可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的
- 保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。
- 可以实现字符串常量池。
- 由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象
# String s = new String("aa") 创建了几个对象
- 答案为 两个
- 使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”
- “如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。
- 为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？
- 由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一个字符串常量池。通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式：
- 当执行 String s = "aa" 时，Java 虚拟机会先在字符串常量池中查找有没有“aa”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“aa”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“aa”这个对象，然后将其地址返回，赋给变量 s
- new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象

# 字符串常量池在内存中的什么位置呢？
- Java 8 之前，字符串常量池在永久代/方法区中的字符串常量池
- Java 8 之后，移除了永久代，字符串常量池就移到了堆中。

# 能再简单给我解释一下方法区，永久代和元空间的概念吗？
- 方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；
- 永久代是 HotSpot 虚拟机中对方法的一个实现，就像是接口的实现类；
- Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一个实现。
- 永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制，虽然也会发生内存溢出，但出现的几率相对之前就小了很多。
- 总结:方法区是Java虚拟机的接口(规范)  永久代和元空间是它的两种实现

#  String 的 intern 方法
- 使用双引号声明的字符串对象会保存在字符串常量池中。
- 使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。
- 针对没有使用双引号声明的字符串对象来说 如果想把内容也放入字符串常量池的话，可以调用 intern() 方法来完成。
- Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存空间

# 如何比较两个字符串相等啊？
- Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。

# 最优雅的Java字符串拼接是哪种方式？
- 在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：
- 循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不同的进行垃圾回收，从而降低了程序的性能。”
- String.concat 遇到字符串为null会抛出异常
- +号操作符不会 因为底层用的StringBuilder
- String.join方式     StringJoiner 对象
- org.apache.commons.lang3.StringUtils    内部使用的是StringBulider  不用担心NullPointerExceotion  

# 如何在Java中优雅地分割String字符串？
- 用Sting类的.split方法  但是使用正则 可以避免特殊符号的方式  正则表达式记得使用静态方式定义
- 可以用"[分割字符]"
- 可以使用Pattern类的quote方法 包裹英文逗点

# 问题:ElasticSearch适合存储什么类型的数据  应用场景有哪些